#lang racket
(provide (all-defined-out))
(define valid-char*
  (string->list
   " -_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"))
(define (valid-char? char)
  (if (memq char valid-char*) #t #f))
(define (purify-string str)
  (define l (string-length str))
  (define s (make-string l))
  (let iter ((i 0))
    (cond ((= i l) s)
          ((valid-char? (string-ref str i))
           (string-set! s i (string-ref str i))
           (iter (+ i 1)))
          (else
           (string-set! s i #\space)
           (iter (+ i 1))))))
(define (read-command)
  (let* ((str (read-line))
         (purified-str (purify-string str))
         (port (open-input-string purified-str))
         (seq (in-port read port)))
    (sequence->list seq)))
;<command> ::= <verbA>
;           |  <verbB> <obj>
;           |  <verbC> <obj> <prep> <obj>
(define (get-method obj msg) (obj msg))
(define (method? x) (procedure? x))
(define (tell obj msg . arg*)
  (let ((method (get-method obj msg)))
    (if (method? method)
        (apply method obj arg*)
        (error 'tell "unknown method [~s] for object [~s]"
               msg (get-id obj)))))
(define make-obj
  (let ()
    (define id* '())
    (define (fresh? id)
      (not (memq id id*)))
    (define (add-id! id)
      (if (symbol? id)
          (if (fresh? id)
              (set! id* (cons id id*))
              (error 'make-obj "id [~s] has been used" id))
          (error 'make-obj "id [~s] should be a symbol" id)))
    (lambda (id)
      (add-id! id)
      (lambda (msg)
        (case msg
          ((id) (lambda (self) id))
          ((type) (lambda (self) '()))
          (else #f))))))
(define (get-id obj) (tell obj 'id))
(define (get-id* obj*) (map get-id obj*))
(define (type-of obj) (tell obj 'type))
(define (obj-eq? a b)
  (eq? (get-id a) (get-id b)))
(define (add-obj obj obj*)
    (cond ((null? obj*) (list obj))
          ((obj-eq? obj (car obj*)) obj*)
          (else (cons (car obj*)
                      (add-obj obj (cdr obj*))))))
(define (remove-obj obj obj*)
    (cond ((null? obj*) '())
          ((obj-eq? obj (car obj*)) (cdr obj*))
          (else (cons (car obj*)
                      (remove-obj obj (cdr obj*))))))
(define (make-clock id)
  (define obj (make-obj id))
  (define time 0)
  (define type (cons 'clock (type-of obj)))
  (define obj* '())
  (define (add-obj! obj)
    (set! obj* (add-obj obj obj*)))
  (define (remove-obj! obj)
    (set! obj* (remove-obj obj obj*)))
  (define (notify!)
    (for-each (lambda (obj)
                ;the notified objects have to implement the method [time]
                (tell obj 'time time))
              obj*))
  (lambda (msg)
    (case msg
      ((time) (lambda (self) time))
      ((obj*) (lambda (self) obj*))
      ((type) (lambda (self) type))
      ((add-obj!) (lambda (self obj)
                    (add-obj! obj)))
      ((remove-obj!) (lambda (self obj)
                       (remove-obj! obj)))
      ((tick!) (lambda (self)
                 (set! time (+ time 1))
                 (notify!)))
      (else (get-method obj msg)))))
(define (make-bag id)
  (define obj (make-obj id))
  (define type (cons 'bag (type-of obj)))
  (define item* '())
  (lambda (msg)
    (case msg
      ((item*) (lambda (self) item*))
      ((add-item!) (lambda (self obj)
                     (set! item* (add-obj obj item*))))
      ((remove-item!) (lambda (self obj)
                        (set! item* (remove-obj obj item*))))
      (else (get-method obj msg)))))
